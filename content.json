{"meta":{"title":"筱帅的博客","subtitle":"理想的路总是为有信心的人预备着。","description":null,"author":"XiaoShuai","url":"http://xiaoshuai.club"},"pages":[{"title":"tags","date":"2018-04-26T06:31:11.000Z","updated":"2018-05-04T12:17:31.647Z","comments":false,"path":"tags/index.html","permalink":"http://xiaoshuai.club/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-26T06:31:46.000Z","updated":"2018-05-04T12:20:12.439Z","comments":false,"path":"categories/index.html","permalink":"http://xiaoshuai.club/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-04-26T06:32:20.000Z","updated":"2018-05-04T12:47:32.794Z","comments":true,"path":"about/index.html","permalink":"http://xiaoshuai.club/about/index.html","excerpt":"","text":""}],"posts":[{"title":"java面试总结(一)","slug":"java面试总结(一)","date":"2018-05-20T07:34:26.000Z","updated":"2018-05-20T08:53:56.258Z","comments":true,"path":"2018/05/20/java面试总结(一)/","link":"","permalink":"http://xiaoshuai.club/2018/05/20/java面试总结(一)/","excerpt":"","text":"1、面向对象的特征有哪些方面 抽象:是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承:是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 封装:通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态：多态是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态分为编译时的多态和运行时的多态。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 2、访问修饰符public,private,protected,以及不写（默认）时的区别 修饰符 当前类 同包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。 3、String 是最基本的数据类型吗 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。 4、float f=3.4;是否正确 不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗 对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。 6、Java有没有goto goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 7、int和Integer有什么区别 Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Jdk 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double123456789class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：1234567public class Test03 &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; IntegerCache是Integer的内部类，其代码如下所示：12345678910111213141516171819202122232425262728293031323334353637383940/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。 8、&amp;和&amp;&amp;的区别 &amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。如果你熟悉JavaScript，那你可能更能感受到短路运算的强大。 9、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法 通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。1String str = new String(\"hello\"); 上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。较新版本的Java（从Java 6的某个更新开始）中使用了一项叫”逃逸分析”的技术，可以将一些局部对象放在栈上以提升对象的操作性能。 10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少 Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。 11、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上 在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 12、用最有效率的方法计算2乘以8 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。我们为编写的类重写hashCode方法时，可能会看到如下所示的代码。1234567891011121314151617181920212223242526272829303132333435public class PhoneNumber &#123; private int areaCode; private String prefix; private String lineNumber; public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + areaCode; result = prime * result + ((lineNumber == null) ? 0 : lineNumber.hashCode()); result = prime * result + ((prefix == null) ? 0 : prefix.hashCode()); return result; &#125;public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; PhoneNumber other = (PhoneNumber) obj; if (areaCode != other.areaCode) return false; if (lineNumber == null) &#123; if (other.lineNumber != null) return false; &#125; else if (!lineNumber.equals(other.lineNumber)) return false; if (prefix == null) &#123; if (other.prefix != null) return false; &#125; else if (!prefix.equals(other.prefix)) return false; return true; &#125;&#125; 13、数组有没有length()方法？String有没有length()方法 数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。","categories":[{"name":"面试","slug":"面试","permalink":"http://xiaoshuai.club/categories/面试/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://xiaoshuai.club/tags/java基础/"}]},{"title":"自述","slug":"自述","date":"2018-05-05T05:57:15.000Z","updated":"2018-05-17T02:56:10.518Z","comments":true,"path":"2018/05/05/自述/","link":"","permalink":"http://xiaoshuai.club/2018/05/05/自述/","excerpt":"关于我为何要做这么个博客首先介绍一下我自己的背景: 我是一只萌萌哒的程序猿,毕业于山东的一所普通的大专院校,大学里学的是与计算机无关的行业,自己非常的喜欢编程,在大学的时候就一边学习自己的专业知识一边自学java编程,在学校的时候就自己写点小玩意,17年毕了业之后去了公司就在公司里写公司里的项目,现在已经成长为一只有着两年开发经验的程序猿了. 程序猿","text":"关于我为何要做这么个博客首先介绍一下我自己的背景: 我是一只萌萌哒的程序猿,毕业于山东的一所普通的大专院校,大学里学的是与计算机无关的行业,自己非常的喜欢编程,在大学的时候就一边学习自己的专业知识一边自学java编程,在学校的时候就自己写点小玩意,17年毕了业之后去了公司就在公司里写公司里的项目,现在已经成长为一只有着两年开发经验的程序猿了. 程序猿 为啥做这个博客 身为一只程序猿每天都沉浸在代码中无法自拔,每天不是在写bug就是再写bug的路上,做这个博客的初衷在于有时候自己出了一些bug去网上找解决的办法都是千篇一律,而且又咋又乱还得一篇一篇的看太麻烦,所以有的时候我就在想不如我自己做一个博客把自己在学习和工作中遇到的问题全都记录在上面,等着以后再出现相同的问题了直接去自己的博客里找就ok了,这样能节省很大一部分的时间. 怎么做出来的环境和工具的选择 域名: 从有这个想法一直到网站正式的使用我感觉最简单的就是域名了,我用的是阿里云的万网域名,当时是第一次购买,只用了7块钱就买了一年的.club的顶级域名. 万网 服务器: 像我这么穷逼的程序猿当然是不会花大价钱去买一台服务器的啦,在这里我选择的是GitHub提供的GitHub Pages功能,这个功能能让你在不花一分钱的情况下快速的搭建一个自己的个人博客. GitHub Page 框架: 搭建这个博客的框架我选用的是HEXO+Node.js+Git的组合,HEXO可以提供给我们大量的精美的博客模版供我们使用,Node.js提供给我们一个JavaScript的运行环境,Git工具便于我们生成项目和往GitHub上发布项目. HEXO Node.js Git 模版: 我的博客是用的Simon Ma大佬的Tomotoes的主题,如果是小白的话不推荐用这个主题,在互联网上关于这个主题的内容除了作者自己发的只外很难再找到别的,我在用这个主题的时候就遇到了很多的问题只能自己一点点的解决,所以我还是推荐大家使用Next主题,毕竟比较常见. Tomotoes 博文编写工具: 在选这个时候我自己纠结了好久,因为我这个人有强迫症,我要用什么软件就要用最好最顺心的从不将就,所以我基本上把市面上所有的Markdown的编辑器全部试了一遍,最后我还是选择了GitHub自家的Atom,其实MarkdownPad 2这个工具也是不错的但是有一点就是你要是用专业版的话是要收费的,所以像我这样穷逼毅然决然的选择了Atom,安卓的话我用的是Markdown X,苹果我没用所以我也懒的去找工具了,据说印象笔记和有道云笔记也是不错的. Atom 感谢 在最后首先要感谢GitHub团队提供的这么方便的这么一个平台,还要感谢Simon Ma大佬提供的这么精美的模版,在这里我仅表示我个人向你们表示感谢,最后的最后贴上我人生中的第一段代码,我想也是所有程序员的第一段代码,那就是大名鼎鼎的HelloWrold,就是因为它的存在让我们从此踏上了一条不归路.123public static void main(String[] args) &#123; System.out.println(\"Hello World\");&#125;","categories":[{"name":"短文","slug":"短文","permalink":"http://xiaoshuai.club/categories/短文/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiaoshuai.club/tags/随笔/"}]}]}