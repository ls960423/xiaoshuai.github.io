{"meta":{"title":"筱帅的博客","subtitle":"理想的路总是为有信心的人预备着。","description":null,"author":"XiaoShuai","url":"http://xiaoshuai.club"},"pages":[{"title":"about","date":"2018-04-26T06:32:20.000Z","updated":"2018-05-04T12:47:32.794Z","comments":true,"path":"about/index.html","permalink":"http://xiaoshuai.club/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-26T06:31:46.000Z","updated":"2018-05-04T12:20:12.439Z","comments":false,"path":"categories/index.html","permalink":"http://xiaoshuai.club/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-26T06:31:11.000Z","updated":"2018-05-04T12:17:31.647Z","comments":false,"path":"tags/index.html","permalink":"http://xiaoshuai.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringCloud学习(二)","slug":"SpringCloud学习(二)","date":"2018-05-20T14:32:49.000Z","updated":"2018-05-20T14:35:52.885Z","comments":true,"path":"/bolg/posts/SpringCloud学习(二)/","link":"","permalink":"http://xiaoshuai.club/bolg/posts/SpringCloud学习(二)/","excerpt":"","text":"SpringCloud入门概念 1.SpringCloud是什么 基于SpringBoot提供了一整套的微服务解决方案,包括服务注册与发现,配置中心,全链路监控,服务网关,负载均衡,熔断器等组件,除了基于NetFlix的开源组件做高度抽象封装之外,还有一些选型中立的开源组件. 它利用SpringBoot的开发便利性巧妙地简化了分布式系统基础设施的开发,SpringCloud为开发人员提供了快速构建分布式系统的一些工具,它们都可以用SpringBoot的开发风格做到一键启动和部署. 一句话来说:SpringCloud=分布式微服务架构下的一站式解决方案,是各个微服务架构落地技术的集合体,俗称微服务全家桶. SpringCloud是专注于全局的微服务协调治理框架,它将SpringBoot开发的一个个单体微服务整合并管理起来,SpringBoot可以离开SpringCloud独立使用开发项目,但是SpringCloud离不开SpringBoot,属于依赖关系. SpringCloud和Dubbo的最大区别在于:SpringCloud抛弃了Dubbo的RPC通信,采用的是基于HTTP的REST方式.使用Dubbo构建的微服务架构就像组装电脑,各个环节我们的选择自由度很高,但是最终结果很有可能因为一条内存质量差就点不亮了,总是让人不怎么放心,而SpringCloud就像品牌机,在SpringSource的整合下,做了大量的兼容性测试,保证了机器拥有更高的稳定性,但是如果要在使用非原装组件外的东西,就需要对其基础有足够的了解.","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://xiaoshuai.club/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://xiaoshuai.club/tags/SpringCloud/"}]},{"title":"SpringCloud学习(一)","slug":"SpringCloud学习(一)","date":"2018-05-20T14:30:19.000Z","updated":"2018-05-20T14:35:54.049Z","comments":true,"path":"/bolg/posts/SpringCloud学习(一)/","link":"","permalink":"http://xiaoshuai.club/bolg/posts/SpringCloud学习(一)/","excerpt":"","text":"微服务概述: 1.微服务是什么: 微服务的提出者是马丁.福勒(Martin Fowler),在2014年左右提出微服务架构的概念,就目前而言,对于微服务业界还没有一个统一的,标准的定义. 根据马丁.福勒自己对微服务的定义,微服务架构是一种架构模式或者说是一种架构风格,它是倡导将单一应用程序划分成一组小的服务,每个服务运行在其独立的自己的进程中,服务之间互相协调,互相配合,为用户提供最终价值.服务之间采用轻量级的通讯机制互相沟通. 通俗的去讲,微服务化的核心就是将传统的一站式应用,根据业务拆分成一个一个的服务,彻底地去耦合,每一个微服务提供单个业务功能的服务,一个服务做一件事,从技术角度看就是一种小而独立的处理过程,类似进程概念,能够自行单独启动或者销毁,拥有自己独立的数据库. 2.微服务与微服务架构 (1)微服务:可以看做是可视化编程工具里面用Maven开发的一个个独立的小Moudle,它具体是使用Springboot开发的一个小模块,专业的事交给专业的模块来做,一个模块就做这一件事情,它强调的是一个个的个体,每个个体完成一个具体的任务或者功能. (2)微服务架构:见上面马丁.福勒对微服务架构的定义说明. 3.微服务的优缺点: (1)优点:①每个服务足够内聚,足够小,代码容易理解这样能聚焦一个指定的业务功能或业务需求. ②开发简单,开发效率提高,一个服务可能就是专一的只干一件事. ③小的开发团队就能进行开发,可能这个团队只有2到5个人,它是松耦合的,是有功能意义的服务,无论是在开发阶段或部署阶段都是独立的. ④它可以使用不同的语言进行开发. ⑤易于和第三方集成,微服务允许容易且灵活的方式集成自动部署,通过持续集成环境,例如Jenkins,Hudson,Banboo. ⑥易于被一个开发人员理解,修改和维护,这样小团队能够能关注自己的工作成果,无需通过合作才能体现价值. ⑦它允许你利用融合最新技术. ⑧它只是业务逻辑代码,不会和HTML,CSS或其他界面组件混合. ⑨每个微服务都有自己的存储能力,可以有自己的数据库,也可以有统一数据库. (2)缺点: ①开发人员要处理分布式系统的复杂性. ②多服务运维难度,随着服务的增加,运维的压力也随之增加. ③系统部署依赖. ④服务间通信成本. ⑤数据一致性. ⑥系统集成测试. ⑦性能监控. ⑧等等等… 4.微服务技术栈有哪些 微服务技术栈:多种技术的集合体 微服务条目 落地技术 备注 服务开发 Springboot,Spring,SpringMVC 服务配置与管理 Netflix公司的Archaius,阿里的Diamond等 服务注册与发现 Eureka,Consul,Zookeeper等 服务调用 Rest,RPC,gRPC 服务熔断器 Hystrix,Envoy等 负载均衡 Ribbon,Nginx等 服务接口调用(客户端调用服务的简化工具) Feign等 消息队列 Kafka,RabbitMQ,ActiveMQ等 服务配置中心管理 SpringCloudConfig,Chef等 服务路由(API网关) Zuul等 服务监控 Zabbix,Nagios,Metrics,Spectator等 全链路追踪 Zipkin,Brave,Dapper等 服务部署 Docker,OpenStack,Kubernates等 数据流操作开发包 SpringCloudStream(封装与Redis,Rabbit,Kafka等发送接收消息) 时间消息总线 SpringCloudBus 等等等… 5.为什么要选择SpringCloud作为微服务架构 ①它是一个完整的微服务框架. ②支持Rest,Ribbon支持多种可插拔的序列化选择. ③支持多种编程语言. ④支持服务注册/发现,Eureka服务注册表,Karyon服务端框架支持服务滋注册和健康检查. ⑤支持负载均衡,Zuul-服务,动态路由 云端负载均衡Eureka(针对中间层服务器). ⑥支持配置服务,NetflixArchaius SpringCloudServer集中配置. ⑦支持服务调用链监控,Zuul提供边缘服务,API网关. ⑧等等等…","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://xiaoshuai.club/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://xiaoshuai.club/tags/SpringCloud/"}]},{"title":"java面试总结(一)","slug":"java面试总结(一)","date":"2018-05-20T07:34:26.000Z","updated":"2018-05-20T14:25:27.419Z","comments":true,"path":"/bolg/posts/java面试总结(一)/","link":"","permalink":"http://xiaoshuai.club/bolg/posts/java面试总结(一)/","excerpt":"1、面向对象的特征有哪些方面 抽象:是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承:是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。","text":"1、面向对象的特征有哪些方面 抽象:是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承:是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 封装:通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态：多态是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态分为编译时的多态和运行时的多态。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态（也称为前绑定），而方法重写（override）实现的是运行时的多态（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 2、访问修饰符public,private,protected,以及不写（默认）时的区别 修饰符 当前类 同包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。 3、String 是最基本的数据类型吗 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。 4、float f=3.4;是否正确 不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗 对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。 6、Java有没有goto goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 7、int和Integer有什么区别 Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Jdk 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double123456789class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：1234567public class Test03 &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; IntegerCache是Integer的内部类，其代码如下所示：12345678910111213141516171819202122232425262728293031323334353637383940/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。 8、&amp;和&amp;&amp;的区别 &amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。如果你熟悉JavaScript，那你可能更能感受到短路运算的强大。 9、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法 通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。1String str = new String(\"hello\"); 上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。较新版本的Java（从Java 6的某个更新开始）中使用了一项叫”逃逸分析”的技术，可以将一些局部对象放在栈上以提升对象的操作性能。 10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少 Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。 11、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上 在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 12、用最有效率的方法计算2乘以8 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。我们为编写的类重写hashCode方法时，可能会看到如下所示的代码。1234567891011121314151617181920212223242526272829303132333435public class PhoneNumber &#123; private int areaCode; private String prefix; private String lineNumber; public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + areaCode; result = prime * result + ((lineNumber == null) ? 0 : lineNumber.hashCode()); result = prime * result + ((prefix == null) ? 0 : prefix.hashCode()); return result; &#125;public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; PhoneNumber other = (PhoneNumber) obj; if (areaCode != other.areaCode) return false; if (lineNumber == null) &#123; if (other.lineNumber != null) return false; &#125; else if (!lineNumber.equals(other.lineNumber)) return false; if (prefix == null) &#123; if (other.prefix != null) return false; &#125; else if (!prefix.equals(other.prefix)) return false; return true; &#125;&#125; 13、数组有没有length()方法？String有没有length()方法 数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。 14、在Java中，如何跳出当前的多重嵌套循环 在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好） 15、构造器（constructor）是否可被重写（override） 构造器不能被继承，因此不能被重写，但可以被重载。 16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对 不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。在很多Java程序员必看书籍中是这样介绍equals方法的:首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查”参数是否为这个对象的引用”；2. 使用instanceof操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。 17、是否可以继承String类 String 类是final类，不可以被继承。继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。 18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递 是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。12345678910111213141516using System;namespace CS01 &#123; class Program &#123; public static void swap(ref int x, ref int y) &#123; int temp = x; x = y; y = temp; &#125; public static void Main (string[] args) &#123; int a = 5, b = 10; swap (ref a, ref b); // a = 10, b = 5; Console.WriteLine (&quot;a = &#123;0&#125;, b = &#123;1&#125;&quot;, a, b); &#125; &#125;&#125; Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿。 19、String和StringBuilder、StringBuffer的区别 Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方法都没有被synchronized修饰，因此它的效率也比StringBuffer要高。String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用。 20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 21、描述一下JVM加载class文件的原理机制 JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）； Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap； System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 22、char 型变量中能不能存贮一个中文汉字，为什么 char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。 23、抽象类（abstract class）和接口（interface）有什么异同 抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、default、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同 Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 扑克类（一副扑克） * @author * */public class Poker &#123; private static String[] suites = &#123;\"黑桃\", \"红桃\", \"草花\", \"方块\"&#125;; private static int[] faces = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13&#125;; private Card[] cards; /** * 构造器 * */ public Poker() &#123; cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) &#123; for(int j = 0; j &lt; faces.length; j++) &#123; cards[i * 13 + j] = new Card(suites[i], faces[j]); &#125; &#125; &#125; /** * 洗牌 （随机乱序） * */ public void shuffle() &#123; for(int i = 0, len = cards.length; i &lt; len; i++) &#123; int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; &#125; &#125; /** * 发牌 * @param index 发牌的位置 * */ public Card deal(int index) &#123; return cards[index]; &#125; /** * 卡片类（一张扑克） * [内部类] * @author * */ public class Card &#123; private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) &#123; this.suite = suite; this.face = face; &#125; @Override public String toString() &#123; String faceStr = \"\"; switch(face) &#123; case 1: faceStr = \"A\"; break; case 11: faceStr = \"J\"; break; case 12: faceStr = \"Q\"; break; case 13: faceStr = \"K\"; break; default: faceStr = String.valueOf(face); &#125; return suite + faceStr; &#125; &#125;&#125; 测试代码：123456789101112class PokerTest &#123; public static void main(String[] args) &#123; Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card(\"红心\", 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A &#125;&#125; Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：1new Outer().new Inner(); 25、Java中会存在内存泄漏吗，请简单描述 理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。12345678910111213141516171819202122232425import java.util.Arrays;import java.util.EmptyStackException;public class MyStack&lt;T&gt; &#123; private T[] elements; private int size = 0; private static final int INIT_CAPACITY = 16; public MyStack() &#123; elements = (T[]) new Object[INIT_CAPACITY]; &#125; public void push(T elem) &#123; ensureCapacity(); elements[size++] = elem; &#125; public T pop() &#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; private void ensureCapacity() &#123; if(elements.length == size) &#123; elements = Arrays.copyOf(elements, 2 * size + 1); &#125; &#125;&#125; 上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。 26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰 都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的 27、阐述静态变量和实例变量的区别 静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。 28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用 不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。 29、如何实现对象克隆 有两种方式： 1). 实现Cloneable接口并重写Object类中的clone()方法； 2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。123456789101112131415161718192021import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; public static &lt;T&gt; T clone(T obj) throws Exception &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 &#125;&#125; 下面是测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.Serializable;/** * 人类 * @author * */class Person implements Serializable &#123; private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) &#123; this.name = name; this.age = age; this.car = car; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \", car=\" + car + \"]\"; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/** * 小汽车类 * @author * */class Car implements Serializable &#123; private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) &#123; this.brand = brand; this.maxSpeed = maxSpeed; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; @Override public String toString() &#123; return \"Car [brand=\" + brand + \", maxSpeed=\" + maxSpeed + \"]\"; &#125;&#125; 123456789101112131415class CloneTest &#123; public static void main(String[] args) &#123; try &#123; Person p1 = new Person(\"Hao LUO\", 33, new Car(\"Benz\", 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand(\"BYD\"); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是优于把问题留到运行时。","categories":[{"name":"面试","slug":"面试","permalink":"http://xiaoshuai.club/categories/面试/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://xiaoshuai.club/tags/java基础/"}]},{"title":"自述","slug":"自述","date":"2018-05-05T05:57:15.000Z","updated":"2018-05-20T13:57:26.436Z","comments":true,"path":"/bolg/posts/自述/","link":"","permalink":"http://xiaoshuai.club/bolg/posts/自述/","excerpt":"关于我为何要做这么个博客首先介绍一下我自己的背景: 我是一只萌萌哒的程序猿,毕业于山东的一所普通的大专院校,大学里学的是与计算机无关的行业,自己非常的喜欢编程,在大学的时候就一边学习自己的专业知识一边自学java编程,在学校的时候就自己写点小玩意,17年毕了业之后去了公司就在公司里写公司里的项目,现在已经成长为一只有着两年开发经验的程序猿了. 程序猿","text":"关于我为何要做这么个博客首先介绍一下我自己的背景: 我是一只萌萌哒的程序猿,毕业于山东的一所普通的大专院校,大学里学的是与计算机无关的行业,自己非常的喜欢编程,在大学的时候就一边学习自己的专业知识一边自学java编程,在学校的时候就自己写点小玩意,17年毕了业之后去了公司就在公司里写公司里的项目,现在已经成长为一只有着两年开发经验的程序猿了. 程序猿 为啥做这个博客 身为一只程序猿每天都沉浸在代码中无法自拔,每天不是在写bug就是再写bug的路上,做这个博客的初衷在于有时候自己出了一些bug去网上找解决的办法都是千篇一律,而且又咋又乱还得一篇一篇的看太麻烦,所以有的时候我就在想不如我自己做一个博客把自己在学习和工作中遇到的问题全都记录在上面,等着以后再出现相同的问题了直接去自己的博客里找就ok了,这样能节省很大一部分的时间. 怎么做出来的环境和工具的选择 域名: 从有这个想法一直到网站正式的使用我感觉最简单的就是域名了,我用的是阿里云的万网域名,当时是第一次购买,只用了7块钱就买了一年的.club的顶级域名. 万网 服务器: 像我这么穷逼的程序猿当然是不会花大价钱去买一台服务器的啦,在这里我选择的是GitHub提供的GitHub Pages功能,这个功能能让你在不花一分钱的情况下快速的搭建一个自己的个人博客. GitHub Page 框架: 搭建这个博客的框架我选用的是HEXO+Node.js+Git的组合,HEXO可以提供给我们大量的精美的博客模版供我们使用,Node.js提供给我们一个JavaScript的运行环境,Git工具便于我们生成项目和往GitHub上发布项目. HEXO Node.js Git 模版: 我的博客是用的Simon Ma大佬的Tomotoes的主题,如果是小白的话不推荐用这个主题,在互联网上关于这个主题的内容除了作者自己发的只外很难再找到别的,我在用这个主题的时候就遇到了很多的问题只能自己一点点的解决,所以我还是推荐大家使用Next主题,毕竟比较常见. Tomotoes 博文编写工具: 在选这个时候我自己纠结了好久,因为我这个人有强迫症,我要用什么软件就要用最好最顺心的从不将就,所以我基本上把市面上所有的Markdown的编辑器全部试了一遍,最后我还是选择了GitHub自家的Atom,其实MarkdownPad 2这个工具也是不错的但是有一点就是你要是用专业版的话是要收费的,所以像我这样穷逼毅然决然的选择了Atom,安卓的话我用的是Markdown X,苹果我没用所以我也懒的去找工具了,据说印象笔记和有道云笔记也是不错的. Atom 感谢 在最后首先要感谢GitHub团队提供的这么方便的这么一个平台,还要感谢Simon Ma大佬提供的这么精美的模版,在这里我仅表示我个人向你们表示感谢,最后的最后贴上我人生中的第一段代码,我想也是所有程序员的第一段代码,那就是大名鼎鼎的HelloWrold,就是因为它的存在让我们从此踏上了一条不归路.123public static void main(String[] args) &#123; System.out.println(\"Hello World\");&#125;","categories":[{"name":"短文","slug":"短文","permalink":"http://xiaoshuai.club/categories/短文/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiaoshuai.club/tags/随笔/"}]}]}